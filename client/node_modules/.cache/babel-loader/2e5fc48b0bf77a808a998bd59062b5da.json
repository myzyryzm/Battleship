{"ast":null,"code":"class Piece {\n  constructor(size) {\n    this.size = size;\n    this.positions = [];\n    this.hits = [];\n    this.alive = true;\n    this.rotation = 0;\n  }\n\n  hasSunkPiece(dex) {\n    this.hits.push(dex);\n    return this.hits.length === this.positions.length;\n  }\n\n  rotatePiece(spaces) {\n    let rot = this.rotation;\n    let finPos = [];\n    let anchorPoint = rot === 0 || rot === 270 ? Math.min(...this.positions) : Math.max(...this.positions);\n    let anchorRemainder = anchorPoint > 9 ? anchorPoint - anchorPoint % 10 : 0;\n    let nuRot = false;\n\n    for (let i = 0; i < 4; i++) {\n      rot += 90;\n      rot = rot < 360 ? rot : 0;\n      let canRotate = true;\n      finPos = [anchorPoint];\n\n      for (let j = 1; j < this.size; j++) {\n        if (rot === 0) {\n          let dex = anchorPoint + 10 * j;\n          finPos[j] = dex;\n\n          if (dex > 99) {\n            canRotate = false;\n            break;\n          }\n        } else if (rot === 90) {\n          let dex = anchorPoint - j;\n          let rem = dex > 9 ? dex - dex % 10 : 0;\n          finPos[j] = dex;\n\n          if (dex < 0 || rem != anchorRemainder) {\n            canRotate = false;\n            break;\n          }\n        } else if (rot === 180) {\n          let dex = anchorPoint - 10 * j;\n          finPos[j] = dex;\n\n          if (dex < 0) {\n            canRotate = false;\n            break;\n          }\n        } else if (rot === 270) {\n          let dex = anchorPoint + j;\n          let rem = dex > 9 ? dex - dex % 10 : 0;\n          finPos[j] = dex;\n\n          if (dex > 99 || rem != anchorRemainder) {\n            canRotate = false;\n            break;\n          }\n        }\n      }\n\n      if (canRotate) {\n        nuRot = true;\n\n        for (let k = 0; k < finPos.length; k++) {\n          if (spaces.includes(finPos[k])) {\n            nuRot = false;\n            break;\n          }\n        }\n\n        if (nuRot) {\n          break;\n        }\n      }\n    }\n\n    if (nuRot) {\n      this.positions = finPos;\n      this.rotation = rot;\n    }\n  }\n\n}\n\nclass PlayerPieces {\n  constructor() {\n    this.gamePieces = [new Piece(2), new Piece(3), new Piece(3), new Piece(4), new Piece(5)];\n    this.squares = Array(100).fill(0);\n    this.originalSquares = Array(100).fill(0);\n  }\n\n  setOriginalSquares() {\n    this.originalSquares = this.squares;\n  }\n\n  canPlaceGamepiece(arr) {\n    let canPlace = true;\n\n    for (let i = 0; i < arr.length; i++) {\n      if (this.squares[arr[i]] === 1) {\n        canPlace = false;\n        break;\n      }\n    }\n\n    return canPlace;\n  }\n\n  addPiece(spaces, dex) {\n    for (let i = 0; i < spaces.length; i++) {\n      this.squares[spaces[i]] = 1;\n    }\n\n    this.gamePieces[dex].positions = spaces;\n  }\n\n  canAttackPiece(dex) {\n    if (this.squares[dex] > 1) {\n      return false;\n    }\n\n    return true;\n  }\n\n  hasSunkPiece(dex) {\n    let hasSunk = false;\n\n    if (this.squares[dex] === 1) {\n      for (let i = 0; i < this.gamePieces.length; i++) {\n        if (this.gamePieces[i].positions.includes(dex)) {\n          hasSunk = this.gamePieces[i].hasSunkPiece(dex);\n        }\n      }\n    }\n\n    this.squares[dex] += 2;\n    return this.squares[dex] === 3;\n  }\n\n  rotatePiece(dex) {\n    let initSpaces = this.gamePieces[dex].positions;\n    let occupiedSpaces = [];\n\n    for (let i = 0; i < this.gamePieces.length; i++) {\n      if (i != dex) {\n        for (let j = 0; j < this.gamePieces[i].positions.length; j++) {\n          occupiedSpaces.push(this.gamePieces[i].positions[j]);\n        }\n      }\n    }\n\n    this.gamePieces[dex].rotatePiece(occupiedSpaces);\n    let nuSpaces = this.gamePieces[dex].positions;\n\n    for (let i = 0; i < initSpaces.length; i++) {\n      this.squares[initSpaces[i]] = 0;\n      this.squares[nuSpaces[i]] = 1;\n    }\n  }\n\n}\n\nlet user = new PlayerPieces();\nlet opponent = new PlayerPieces();\nexport default [user, opponent];","map":{"version":3,"sources":["/Users/ryzm/Desktop/Battleship/src/playerPieces.js"],"names":["Piece","constructor","size","positions","hits","alive","rotation","hasSunkPiece","dex","push","length","rotatePiece","spaces","rot","finPos","anchorPoint","Math","min","max","anchorRemainder","nuRot","i","canRotate","j","rem","k","includes","PlayerPieces","gamePieces","squares","Array","fill","originalSquares","setOriginalSquares","canPlaceGamepiece","arr","canPlace","addPiece","canAttackPiece","hasSunk","initSpaces","occupiedSpaces","nuSpaces","user","opponent"],"mappings":"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","sourcesContent":["class Piece{\n  constructor(size){\n    this.size = size;\n    this.positions = [];\n    this.hits = [];\n    this.alive = true;\n    this.rotation = 0;\n  }\n\n  hasSunkPiece(dex){\n    this.hits.push(dex);\n    return this.hits.length === this.positions.length;\n  }\n\n  rotatePiece(spaces){\n    let rot = this.rotation;\n    let finPos = [];\n    let anchorPoint = rot === 0 || rot === 270 ? Math.min(...this.positions) : Math.max(...this.positions);\n    let anchorRemainder = anchorPoint > 9 ? anchorPoint - anchorPoint % 10 : 0;\n    let nuRot = false;\n\n    for(let i = 0; i < 4; i++){\n      rot += 90;\n      rot = rot < 360 ? rot : 0;\n      let canRotate = true;\n      finPos = [anchorPoint];\n      for(let j = 1; j < this.size; j++){\n        if(rot === 0){\n          let dex = anchorPoint + 10 * j\n          finPos[j] = dex\n          if(dex > 99){\n            canRotate = false;\n            break;\n          }\n        }\n        else if(rot === 90){\n          let dex = anchorPoint - j\n          let rem = dex > 9 ? dex - dex % 10 : 0;\n          finPos[j] = dex\n          if(dex < 0 || rem != anchorRemainder){\n            canRotate = false;\n            break;\n          }\n        }\n        else if(rot === 180){\n          let dex = anchorPoint - 10 * j\n          finPos[j] = dex\n          if(dex < 0){\n            canRotate = false;\n            break;\n          }\n        }\n        else if(rot === 270){\n          let dex = anchorPoint + j\n          let rem = dex > 9 ? dex - dex % 10 : 0;\n          finPos[j] = dex\n          if(dex > 99 || rem != anchorRemainder){\n            canRotate = false;\n            break;\n          }\n        }\n      }\n      if(canRotate){\n        nuRot = true;\n        for(let k = 0; k < finPos.length; k++){\n          if(spaces.includes(finPos[k])){\n            nuRot = false;\n            break;\n          }\n        }\n        if(nuRot){\n          break;\n        }\n      }\n    }\n    if(nuRot){\n      this.positions = finPos;\n      this.rotation = rot;\n    }\n  }\n}\n\nclass PlayerPieces{\n  constructor(){\n    this.gamePieces = [new Piece(2), new Piece(3), new Piece(3), new Piece(4), new Piece(5)];\n    this.squares = Array(100).fill(0);\n    this.originalSquares = Array(100).fill(0);\n  }\n\n  setOriginalSquares(){\n    this.originalSquares = this.squares;\n  }\n\n  canPlaceGamepiece(arr){\n    let canPlace = true;\n    for(let i = 0; i < arr.length; i++){\n      if(this.squares[arr[i]] === 1){\n        canPlace = false;\n        break;\n      }\n    }\n    return canPlace;\n  }\n\n  addPiece(spaces, dex){\n    for(let i = 0; i < spaces.length; i++){\n      this.squares[spaces[i]] = 1;\n    }\n    this.gamePieces[dex].positions = spaces\n  }\n\n  canAttackPiece(dex){\n    if(this.squares[dex] > 1){\n      return false;\n    }\n    return true;\n  }\n\n  hasSunkPiece(dex){\n    let hasSunk = false;\n    if(this.squares[dex] === 1){\n      for(let i = 0; i < this.gamePieces.length; i++){\n        if(this.gamePieces[i].positions.includes(dex)){\n          hasSunk = this.gamePieces[i].hasSunkPiece(dex);\n        }\n      }\n    }\n    this.squares[dex]+=2;\n    return this.squares[dex] === 3;\n  }\n\n  rotatePiece(dex){\n    let initSpaces = this.gamePieces[dex].positions;\n    let occupiedSpaces = [];\n    for(let i = 0; i < this.gamePieces.length; i++){\n      if(i != dex){\n        for(let j = 0; j < this.gamePieces[i].positions.length; j++){\n          occupiedSpaces.push(this.gamePieces[i].positions[j]);\n        }\n      }\n    }\n    this.gamePieces[dex].rotatePiece(occupiedSpaces);\n    let nuSpaces = this.gamePieces[dex].positions;\n    for(let i = 0; i < initSpaces.length; i++){\n      this.squares[initSpaces[i]] = 0;\n      this.squares[nuSpaces[i]] = 1;\n    }\n  }\n}\n\nlet user = new PlayerPieces()\nlet opponent = new PlayerPieces()\n\nexport default [user,opponent];\n"]},"metadata":{},"sourceType":"module"}